#! /usr/bin/env python

"""Tring things around."""

from click.core import BaseCommand
from dataclasses import dataclass
import math
import random

import click
from rich.console import Console

from bitcoin import txn
from bitcoin import ecdsa
from bitcoin.hashes import sha256
from bitcoin.wallet import gen_key_pair, PublicKey


# not sure where it should belong yet
SIGHASH_ALL = b'\x01'
NET = 'test'

console = Console()
log = console.log


@dataclass
class Wallet:
    public_key: PublicKey
    private_key: int
    address: str

    @property
    def pk(self):
        return self.public_key

    @property
    def sk(self):
        return self.private_key

    @classmethod
    def generate(cls, force: bytes = None):
        sk, pk = gen_key_pair(force=force)

        # we are going to use the develop's Bitcoin parallel universe "test net"
        # for this demo, so net='test'
        address = pk.address(net=NET, compressed=True)

        return cls(public_key=pk, private_key=sk, address=address)

    @property
    def pk_hash(self):
        return PublicKey.from_point(self.public_key).encode(compressed=True, hash160=True)

    def __repr__(self):
        return "\n".join([
            "\nBitcoin wallet:",
            f"1. secret key: {self.sk}",
            "2. public key:",
            f"   X: {format(self.pk.x, '064x').upper()}",
            f"   Y: {format(self.pk.y, '064x').upper()}",
            f"3. Compressed bitcoin address (b58check format): {self.address}",
            f"Verify associated transactions: https://www.blockchain.com/btc-testnet/address/{self.address}\n",
        ])


def BaseScript(wallet: Wallet) -> txn.Script:
    """Basic locking script.
    
    Bitcoin uses a stack-based scripting language, which can gets very
    complicated but boils down to the simple set of instructions below for
    simple transactions.

    Later on, in order to spend the funds transfered to the output we are
    locking here, we will need to satisfy the script instructions.

    This script is saying that any Transaction that aspires to spend this Output
    must satisfy two conditions.
        1) their Public key better hash to `wallet.pk_hash`
        2) the digital signature for the aspiring transaction better validate as
           being generated by this public key’s associated private key

    So it makes sure only the owner and his public key will be able to provide the key and sign the transaction.
    
    """
    return txn.Script([
        txn.Opcode.OP_DUP,           # 1. duplicate
        txn.Opcode.OP_HASH160,       # 2. hash160 it
        wallet.pk_hash,              # 3. public key hash
        txn.Opcode.OP_EQUALVERIFY,   # 4. check this is equal
        txn.Opcode.OP_CHECKSIG       # 5. check signature
    ])

def signature(author, message):
    """Generate the input script signature.
    
    Using the ECDSA algorithm and the author secret key, we generate a simple
    Script, to be used in the input transaction as a signature (i.e. an encoded
    proof of ownership of the private key),
    
    """

    # NOTE: we are generating a random number inside the signing process when
    # we generate sk. This means that our signature would change every time we
    # sign, which is undesirable for a large number of reasons, including the
    # reproducibility of this exercise
    #
    # Please don’t use this anywhere close to anything that touches production
    random.seed(int.from_bytes(sha256(message), 'big'))

    log("signing Bob secret key")
    sig = ecdsa.sign(author.sk, message)
    sig_bytes = sig.encode()
    log(f"message signature: {sig_bytes.hex()}")

    # Append 1 (= SIGHASH_ALL), indicating this DER signature we created encoded "ALL" of the tx (by far most common)
    sig_bytes_and_type = sig_bytes + SIGHASH_ALL
    # Encode the public key into bytes. Notice we use hash160=False so we are revealing the full public key to Blockchain
    pubkey_bytes = PublicKey.from_point(author.pk).encode(compressed=True, hash160=False)
    # Create a lightweight Script that just encodes those two things!
    script_sig = txn.Script([sig_bytes_and_type, pubkey_bytes])
    return script_sig
        


@click.command()
def run():
    # --------------------------------------------------------------------------------------------
    # Create our 2 identities

    console.rule("crafting identities")

    log("generating Bob wallet")
    bob = Wallet.generate(force=b"learning bitcoin, duh")
    print(bob)
    log(f"Bob public key hash: {bob.pk_hash}")

    log("generating Alice wallet")
    alice = Wallet.generate(force=b"learning bitcoin, duh, again")
    print(alice)

    # --------------------------------------------------------------------------------------------
    # Craft our first transaction
    # We will first seed some initial bitcoins from a faucet to our first address (bob).
    # Then we will send part of the fund to 1) Alice and 2) Back to us, paying a
    # fee to the miner in the process.

    # the 2 addresses were created from scratch, without any funds. On the test
    # network, developers can use _faucets_ to request bitcoins. So we send some
    # to our first wallet.
    #
    # tech note: such transaction id are sha256 double hash 9for additional
    # security) of the transaction data structure
    #
    # TODO: print instructions and let one enter the hash manually
    faucet_txn_id = '381d17a987c59a05f74f08661948bc12040d40c187ca242ea18cfe65747becc8'
    faucet_funds = 0.00067
    # Transaction: https://www.blockchain.com/btc-testnet/tx/381d17a987c59a05f74f08661948bc12040d40c187ca242ea18cfe65747becc8

    console.rule("crafing a transaction")

    # the first output will go to our 2nd wallet
    out_alice_script = BaseScript(alice)
    log("TXN output to Alice script hash:", out_alice_script.encode().hex())

    # the second output will go back to us
    out_bob_script = BaseScript(bob)
    log("TXN output to Bob script hash:", out_bob_script.encode().hex())

    # now generate the actual unique transaction input, out of the completed
    # faucet transaction
    tx_faucet = txn.TxIn(
        prev_tx = bytes.fromhex(faucet_txn_id),
        # the faucet likely sent both some money to us, as well as to another
        # address he owns. Each transaction outputs has a index (visibile on any
        # block explorer) that we indicate below
        prev_index = 0,
        # this field will have the digital signature, to be inserted later
        script_sig = None,
        # by convention  this script will be used in place of script_sig, as we
        # wait to be able to generate it
        prev_tx_script_pubkey = out_bob_script,
    )

    log(f"computing transaction fee for {faucet_funds} bitcoins")
    sat = txn.to_satoshi(faucet_funds)
    size = txn.txn_size(1, 2)
    fee = 10 * size  # estimated market rate: 10 Sat/B
    log("splitting transaction amounts between the 2 output wallets")
    transfer1 = math.floor(sat / 2)
    # we actuallt don't need to indicate anywhere the fee amount. Any bitcoins
    # left in the equation: `total_funds - transfers` is the money to be taken
    # by the miner
    transfer2 = sat - transfer1 - fee

    log(f"Transfer: B0.00067 <> {sat} Satoshis:")
    log(f"Alice: {transfer1}")
    log(f"Bob:   {transfer2}")
    log(f"Fee:   {fee} ({size} bytes)")

    # we will send to the target wallet (Alice)
    #
    # again: the script basically specifies the conditions under which the
    # amount transfered (so the output transaction) will be later on authorized
    # to be spent
    tx_alice = txn.TxOut(amount=transfer1, script_pubkey=out_alice_script)
    # And back to us (Bob)
    tx_bob = txn.TxOut(amount=transfer2, script_pubkey=out_bob_script)

    log("generating the final transaction")
    tx = txn.Tx(
        version=1,
        tx_ins=[tx_faucet],
        tx_outs=[tx_alice, tx_bob],
    )

    message = tx.encode(sig_index=0)
    log(f"message encoding (to be digitally signed): {message.hex()}")

    # -------------------------------------------------------------------------------------------
    # Signature

    console.rule("signing transaction")

    tx_faucet.script_sig = signature(bob, message)

    # -- That's it --------------------------------------------------------------------------------
    log(f"Transaction\n\tid: {tx.id()}\n\tsize: {len(tx.encode())} bytes")
    log('Message:', tx.encode().hex())

    log("Go over https://blockstream.info/testnet/tx/push and broadcast the Bitcoin message")
    # TODO: transaction = input("Once done, press <ENTER> to continue...")
    input("... Once done, press <ENTER> to continue ...")
    transaction = 'e86c401a45a7e4a6821e73c141b6285d2a9c7e4b3e9ade825a5d11dd751835fa'
    # https://blockstream.info/testnet/tx/e86c401a45a7e4a6821e73c141b6285d2a9c7e4b3e9ade825a5d11dd751835fa
    # https://www.blockchain.com/btc-testnet/tx/e86c401a45a7e4a6821e73c141b6285d2a9c7e4b3e9ade825a5d11dd751835fa
    # https://www.blockchain.com/btc-testnet/block/2007857

    console.rule("spending TXO to Carol")
    consolidate(transaction, alice, bob, transfer1 + transfer2)


def consolidate(transaction: str, alice: Wallet, bob: Wallet, funds: int):
    """Let’s put everything together now: create one last identity and
    consolidate all of our remaining funds in this one wallet.

    So we're gonna transfer the funds from Bob and Alice to this 3rd wallet,
    owned by Carol.

    Arguments:
        transaction: id of the last transfer from faucet to ALice and Bob
        alice/bob: recipient wallets
        funds: bitcoins to transfer. It should tally to the sum of the 2 other wallets

    """

    log("generating Carol wallet")
    carol = Wallet.generate(force=b"still learning bitcoin, duh")
    print(carol)

    # -- Forging the transaction
    # first input of the transaction
    log("crafting first input of the trasaction (Alice, index=0)")
    tx_in_alice = txn.TxIn(
        prev_tx=bytes.fromhex(transaction),
        # indcate Alice part of the transaction
        prev_index=0,
        script_sig=None, # digital signature to be inserted later
    )

    # reconstruct the script_pubkey locking this UTXO (note: it's the first
    # output index in the referenced transaction, but the owner is the second
    # identity/wallet!) recall this information is "swapped in" when we
    # digitally sign the spend of this UTXO a bit later
    script_in_alice = BaseScript(alice)
    tx_in_alice.prev_tx_script_pubkey = script_in_alice
    log("TXN input 1 of Alice script hash:", script_in_alice.encode().hex())

    log("crafting second input of the trasaction (Bob, index=1)")
    tx_in_bob = txn.TxIn(
        prev_tx=bytes.fromhex(transaction),
        # indicate Bob part of the transaction
        prev_index=1,
        script_sig=None, # digital signature to be inserted later
    )

    script_in_bob = BaseScript(bob)
    tx_in_bob.prev_tx_script_pubkey = script_in_bob
    log("TXN input 2 of Bob script hash:", script_in_bob.encode().hex())

    # define the (single) output
    size = txn.txn_size(2, 1)
    fee = 10 * size  # 10 Sat/B
    tx_out_carol = txn.TxOut(
        amount=funds - fee,
        script_pubkey=None, # locking script, inserted separately right below
    )

    # declare the owner as identity 3 above, by inserting the public key hash
    # into the Script "padding"
    tx_out_carol.script_pubkey = BaseScript(carol)

    # create the aspiring transaction object
    tx = txn.Tx(
        version = 1,
        tx_ins = [tx_in_alice, tx_in_bob], # 2 inputs this time!
        tx_outs = [tx_out_carol], # ...and a single output
    )

    # digitally sign the spend of the first input of this transaction
    # note that index 0 of the input transaction is our second identity! so it must sign here
    message1 = tx.encode(sig_index=0)
    tx_in_alice.script_sig = signature(alice, message1)

    # digitally sign the spend of the second input of this transaction
    # note that index 1 of the input transaction is our first identity, so it signs here
    message2 = tx.encode(sig_index=1)
    tx_in_bob.script_sig = signature(bob, message2)

    # and that should be it!
    print('\nTransaction id:', tx.id())
    print('Transaction encoded:', tx.encode().hex())

    # transaction = 'd57d14e6a025122236f430dc3eec3b8a04333676bbd3a475fb6900e0e55312db'
    # of block: https://blockstream.info/testnet/block/000000000000004a8b9ffb2208a7811ec0522582c1a81faa2e26c46d428032d0


if __name__ == '__main__':
    run()